import type {
  Post,
  Image,
  APIError,
  Community,
  Comment,
} from "@discuit-community/types";
import { loadConfig } from "./utils/config";
import { DiscuitBot } from "./discuit";
import { LlmService } from "./llm";
import {
  CommentModel,
  DiscuitUrls,
  PostModel,
  type Result,
} from "@discuit-community/client";

import log from "./utils/log";
import ascii from "./utils/ascii";
import checkConsent from "./utils/permissions";

import { AltTextTracker } from "./roundup/tracker";
import { generateWeeklyReport } from "./roundup/reports";

const DEV_MODE = Bun.env.NODE_ENV === "development";
const urls = new DiscuitUrls();

function genNewId() {
  const id = Math.random().toString(36).substring(2, 15);
  return [id, ascii.dim(`[${id}]`)];
}

async function fetchCommunity(name: string): Promise<Result<Community>> {
  const communityResult = await fetch(urls.api.community(name, true));
  const community = (await communityResult.json()) as APIError | Community;

  if ("status" in community) return [null, community];
  return [community, null];
}

async function generateAltText(
  llm: LlmService,
  post: PostModel,
  community: Community,
  gidText: string,
  genId: string,
) {
  try {
    const descriptions = await Promise.all(
      post.raw.images.map(async (image, index) => {
        const result = await llm.analyzeImage(
          image,
          `${genId}-${index}`,
          post.raw,
          community,
        );
        return result.altText;
      }),
    );

    const plural = post.raw.images.length > 1;
    const altTextLink =
      "[what is alt text?](https://www.perkins.org/resource/how-write-alt-text-and-image-descriptions-visually-impaired/)";
    const consentUrl =
      "https://github.com/discuit-community/alt-text-bot/blob/main/CONSENT.md";

    const replyBody = {
      header: `**alt text for ${plural ? "these" : "this"} image${plural ? "s" : ""}:**`,
      body: descriptions
        .map((text, index) => `- **image ${index + 1} description:** ${text}`)
        .join("\n"),
      footer:
        "------\n\n" +
        "i am a bot, and this action was performed automatically. " +
        "image descriptions were generated by a large language model. " +
        `want to opt out? see [here](${consentUrl}).`,
      opNotice:
        "------\n\n" +
        `*i did my best here, but let's be realâ€”you'd probably do way ` +
        `better than me. maybe give it a shot next time?*`,
    };

    const [_commentResult, _commentError] = await post.comment({
      body: Object.values(replyBody).join("\n\n"),
    });

    if (_commentError)
      console.error(`${gidText} error posting comment:`, _commentError);
    else console.log(`${gidText} posted comment successfully`);
  } catch (error) {
    console.error(`${gidText} error posting comment:`, error);
  }
}

async function main() {
  try {
    const config = loadConfig();
    const altTextDelayMs = config.altTextDelayMs ?? 180_000;

    const tracker = new AltTextTracker();
    await tracker.initialize();

    const llm = new LlmService(config);
    const bot = new DiscuitBot(config);

    const [loginResult, loginError] = await bot.login();
    if (loginError) {
      const errorInfo = {
        error: loginError.message || String(loginError),
        code: loginError.code?.toString() || "unknown",
      };

      log("failed to log in", errorInfo, {
        logLevel: "error",
        trailingNewline: true,
      });
      return;
    }

    console.log(`logged in as @${loginResult.username}`);

    const handleNewImagePost = async (_post: Post) => {
      tracker.trackImagePost(_post);
      await new Promise((res) => setTimeout(res, altTextDelayMs));
      const [genId, gidText] = genNewId();

      // fetch things
      const post = new PostModel(bot.getClient, _post);
      if (!post.raw.author) return;

      const [community, communityError] = await fetchCommunity(
        post.raw.communityName,
      );
      if (communityError || !community) {
        console.error(
          `error fetching community: ${communityError.status} ${communityError.message}`,
        );
        return;
      }

      const consent = DEV_MODE
        ? { user: true, community: true }
        : checkConsent(post.raw.author, community);

      if (!consent.community || !consent.user) {
        log("user or community not consented", {
          postId: post.raw.publicId,
          community: String(consent.community),
          user: String(consent.user),
        });
        return;
      }

      const [comments, commentsError] = await post.getComments();
      if (commentsError) {
        console.error(
          `error fetching comments: ${commentsError.status} ${commentsError.message}`,
        );
        return;
      }

      // checks
      if (DEV_MODE && post.raw.username !== config.discuit.username) return;
      if (!post.raw.author) {
        log("author not found", {
          postId: post.raw.publicId,
          community: String(consent.community),
          user: String(consent.user),
        });
        return;
      }

      const hasAltText = comments
        ? comments.some((c: CommentModel) =>
            /alt.?text|description|image description/i.test(c.raw.body),
          )
        : false;
      if (hasAltText) {
        tracker.trackAltTextAdded(
          post.raw.publicId,
          post.raw.username,
          new Date(),
          false,
        );
        log("alt text already provided by user", {
          postId: post.raw.publicId,
        });
        return;
      }

      await generateAltText(llm, post, community, gidText, genId);
      tracker.trackAltTextAdded(
        post.raw.publicId,
        "alttextbot",
        new Date(),
        true,
      );
    };

    const handleNewComment = async (_post: Post, _comment: Comment) => {
      const [genId, gidText] = genNewId();
      console.log("New comment received:", _comment.body);

      // fetch things
      const comment = new CommentModel(bot.getClient, _comment);
      const post = new PostModel(bot.getClient, _post);

      if (/alt.?text|description|image description/i.test(_comment.body)) {
        tracker.trackAltTextAdded(
          _post.publicId,
          _comment.username,
          new Date(_comment.createdAt),
          false,
        );
      }

      if (!post.raw.author) return;

      if (!comment.raw.body.includes(`@${config.discuit.username}`)) return;
      const [community, communityError] = await fetchCommunity(
        post.raw.communityName,
      );
      if (communityError || !community) return;

      const consent = DEV_MODE
        ? { user: true, community: true }
        : checkConsent(post.raw.author, community);

      if (!consent.user && comment.raw.username !== post.raw.username) {
        const optInUrl =
          "https://github.com/discuit-community/alt-text-bot/blob/main/CONSENT.md";
        await comment.reply(
          `@${post.raw.username} has not opted into alt text generation, but they can opt in [here](${optInUrl}).`,
        );
        return;
      }

      await generateAltText(llm, post, community, gidText, genId);
    };

    await bot.startMonitoring(handleNewImagePost, handleNewComment);
  } catch (error) {
    console.error("an error occurred:", error);
    process.exit(1);
  }
}

main().catch(console.error);
